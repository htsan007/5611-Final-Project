By: Harvey Tsang

***Introduction:***
---
For the final project I chose to do option 4, which was to implement a technique that was discussed in class and something I didnâ€™t already implement. I settled on an Eulerian smoke simulation with the aim of extending it to fire. We talked about Eulerian fluid in class, so there is a direct relation to my project topic. Eulerian fluid follows changes in flow over a single location in space and utilizes the Navier-Stokes equation to help calculate the flow of incompressible fluid (smoke and fire in my case). The state-of-the-art way to implement fire and smoke as fluid often includes volumetric fluid solvers, often using some form of the Navier-Stokes equation and treating the simulation space as a flow-grid. An example used by lots of research in fire-safety is the Fire Dynamics Simulator (FDS), which uses a Large eddy simulation for turbulance using the Navier-Stokes equation, and a Smokeview (SMV) program used to display the fire and smoke. As seen in <a href="https://www.sciencedirect.com/science/article/abs/pii/S0379711223001467"> Real-time visualization of smoke for fire safety engineering applications </a>  AND in <a href="https://history.siggraph.org/wp-content/uploads/2023/01/2004-Poster-101-Barrero_CFD-and-Realistic-Visualization-for-the-Analysis-of-Fire-Scenarios.pdf"> Computation and Representation of Fire and Smoke in Buildings </a>. Here is the direct source for <a href="https://pages.nist.gov/fds-smv/"> FDS-SMV </a>. Another flow-grid solver example, <a href="https://dl.acm.org/doi/pdf/10.1145/3388767.3407380"> Sparse Smoke Simulations in Houdini </a> , implements smoke using a more efficient and sparse fluid solver that skips inactive spaces, where the traditional volumetric fluid solver does not. However, their approach still derives from solving the Navier-Stokes equations.

***My approach and key algorithms:***
---
In my implementation, I follow the code examples as provided from Jo Stam's <a href="http://graphics.cs.cmu.edu/nsp/course/15-464/Fall09/papers/StamFluidforGames.pdf"> Real-Time Fluid Dynamics for Games </a>, which uses a simplified version of the Navier-Stokes equations to create a more stable simulation as seen here: 
<p align="center">
  <img src="./docs/assets/jostamEquations.JPG" width="500" height="250"> .
</p>

This approach involves advection and diffusion of the fluid's density, as well as advection, diffusion, and projection of the velocity. These density and velocity components are represented within a grid covering the whole simulation space. Calculating the diffusion of a component involves using the Gauss-Seidel solver which essentially finds the component that when diffused backwards will yield the current value. This approach is relatively simple and also stable. For the advection, a simple linear backtrace is used, where the velocity is traced backwards and the value at the grid-cell it lands in will be used. Using a backtrace approach allows for better stability than a forward approach. Finally, for the velocity, projection is used to ensure best stability, mass conservation, and fluid incompressability. 

Because this implementation utilizes a grid to model the flow of velocity and density, the computation scales up with the size of the scene. There are nested loops iterating across the rows and columns of the grid for advection, diffuse, projection, and other steps for initialization and scene visualization. This makes computation time atleast O(N^2). Due to this fact, I had to restrict my scene to a small window for it to run smoothly in real-time. This bottleneck may be avoided if you were to do an offline simulation or use a different language. I implemented the simulation in processing(java based language) for easier visualization and consistency with my other projects, which isn't the best for real-time physics simulations, where as the author's originally wrote their version in C.
 
